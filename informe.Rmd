---
title: "Trabajo 1 - Muestreo y Planificación de Encuestas I"
author: "Matias Bajac - Lucas Pescetto - Andres Vidal"
date: '2023-04-10'
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.show = "all")

rm(list = ls())

library(tidyverse)
library(haven)
library(survey)
library(sampling)
library(ggplot2)
library(gridExtra)

set.seed(0)
```

# Preprocesamiento de los datos

```{r data_processing, include=FALSE}
is_nbi_missing <- function(x) x %in% c(8, 9)
is_nbi_var <- function() starts_with("NBI_")
mutate_nbi <- function(x) zap_labels(x) %>% if_else(is_nbi_missing(.), 0, .)
select_nbi <- function(x) select(x, is_nbi_var(), -NBI_CANTIDAD)
has_xo <- function(x) if_else(x$HOGCE09 == 0, 1, 0)
has_nbi <- function(x) if_else(x$NBI_TOTAL >= 4, 1, 0)

load("datos.RData")
data <- rio_branco %>%
  mutate(across(is_nbi_var(), ~ mutate_nbi(.))) %>%
  mutate(NBI_TOTAL = rowSums(select_nbi(.)), XO = has_xo(.)) %>%
  mutate(NBI = has_nbi(.), ID = paste(ID_VIVIENDA, HOGID)) %>%
  filter(!duplicated(ID)) %>%
  select(nbi = NBI, xo = XO)

t_nbi <- sum(data$nbi)
t_xo <- sum(data$xo)

N <- nrow(data)
```


# Distribución empírica del estimador

## Funciones Auxiliares

Definimos funciones auxiliares para facilitar el resto del análisis.
- `estimate_total` recibe un nombre de variable y un diseño de muestreo para estimar un total poblacional. Envuelve la función `svytotal` del paquete `survey` para facilitar su uso.
- `estimate_totals` recibe un nombre de variable y una lista de diseños de muestreo y estima el total poblacional para cada diseño. Se utiliza especialmente para automatizar la aplicación sobre varios tamaños de muestra.
- `show_results` recibe un nombre de variable y una lista de resultados para mostrarlos de forma estándar.
- `confint_norm` recibe un estimador (resultado de `svytotal`) y calcula el intervalo de confianza del 95% asumiendo distribución normal.

```{r auxiliar}
estimate_total <- function(var, design) {
  svytotal(as.formula(paste0("~", var)), design, deff = TRUE)
}

estimate_totals <- function(var, design_list) {
  lapply(design_list, function(design) estimate_total(var, design))
}

show_results <- function(var, named_result_list) {
  as.data.frame(t(named_result_list), row.names = var)
}

confint_norm <- function(t_estimate) {
  t <- coef(t_estimate)
  se <- SE(t_estimate)

  ci <- cbind(
    t - qnorm(0.975) * se,
    t + qnorm(0.975) * se
  )
  colnames(ci) <- c("2.5%", "97.5%")
  ci
}
```



## Muestreo del estimador

```{r estimate_dist_sample}
sample_t_estimate <- function(var, sample_size, get_sample, get_design) {
  n_simulations <- 1000

  replicate(n_simulations, {
    sample <- get_sample(sample_size)
    design <- get_design(sample)
    coef(estimate_total(var, design))
  })
}
```

```{r estimate_dist_plots, include=FALSE}
empirical_distribution_sir <-
  function(var, sample_sizes, get_sample, get_design) {
    result <- lapply(sample_sizes, function(sample_size) {
      # Simular
      t <- data.frame(
        estimate = sample_t_estimate(var, sample_size, get_sample, get_design)
      )

      # Regla de Scott para el ancho de los bins
      binwidth <- 3.5 * sd(t$estimate) / (sample_size^(1 / 3))

      # Graficar Histograma + Curva de densidad
      plot <- ggplot(t, aes(x = estimate, y = after_stat(density))) +
        geom_histogram(binwidth = binwidth, color = "black", fill = "white") +
        geom_density(alpha = 0.2, fill = "blue") +
        geom_vline(
          aes(xintercept = get(paste0("t_", var))),
          color = "red",
          linewidth = 1
        ) +
        labs(x = var, y = "Density") +
        theme_classic()


      list(plot = plot, q95 = quantile(t$estimate, c(0.025, 0.975)))
    })

    plots <- lapply(result, function(r) r$plot)
    quantiles <- lapply(result, function(r) r$q95)
    names(quantiles) <- sample_sizes

    grid.arrange(grobs = plots, padding = 5)

    as.data.frame(t(as.data.frame(quantiles)))
  }
```


# Diseño de muestreo SIR

## Definición del diseño

```{r sir_design}
get_sir_design <- function(sample) {
  svydesign(
    ids = ~1,
    data = sample,
    # Pesos para el estimador t_pwr
    probs = nrow(sample) / N
  )
}
```

## Algoritmo de selección

```{r sir_sampling}
get_sir_sample <- function(sample_size) {
  index <- srswr(sample_size, N)
  getdata(data, index)
}
```

## Obtener muestras finales
```{r sir_samples}
sample_sizes <- c(150, 600, 1000)
sir_samples <- lapply(sample_sizes, get_sir_sample)
names(sir_samples) <- sample_sizes
```

## Obtener objetos de diseño finales

```{r sir_designs}
sir_designs <- lapply(sir_samples, get_sir_design)
```

## Análisis de NBI

### Distribución empírica del estimador para el total de NBI

```{r sir_nbi_estimate_dist, echo=FALSE, results='show'}
t_nbi_quantiles <- empirical_distribution_sir(
  "nbi",
  sample_sizes,
  get_sir_sample,
  get_sir_design
)
```

### Estimación puntual del total de NBI

```{r sir_nbi_estimate}
t_nbi_estimates <- estimate_totals("nbi", sir_designs)
show_results("nbi", t_nbi_estimates)
```

### Efecto diseño del estimador para el total de NBI

```{r sir_nbi_estimate_deff}
t_nbi_estimates_deff <- lapply(t_nbi_estimates, deff)
show_results("nbi", t_nbi_estimates_deff)
```

### Intervalos de confianza para el total de NBI

```{r sir_nbi_estimate_quantiles}
t_nbi_quantiles$range <- t_nbi_quantiles$"97.5%" - t_nbi_quantiles$"2.5%"
t_nbi_quantiles
```

```{r sir_nbi_estimate_confint}
t_nbi_confint <- do.call(rbind, lapply(t_nbi_estimates, confint_norm))
t_nbi_confint$range <- t_nbi_confint$"97.5%" - t_nbi_confint$"2.5%"
rownames(t_nbi_confint) <- sample_sizes
t_nbi_confint
```

## Análisis de XO

### Distribución empírica del estimador para el total de XO

```{r sir_xo_estimate_dist, echo=FALSE, results='show'}
empirical_distribution_sir(
  "xo",
  sample_sizes,
  get_sir_sample,
  get_sir_design
)
```

