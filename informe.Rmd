---
title: "Trabajo 1 - Muestreo y Planificación de Encuestas I"
author: "Matias Bajac - Lucas Pescetto - Andres Vidal"
date: '2023-04-10'
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.show = "all")

rm(list = ls())

library(tidyverse)
library(haven)
library(survey)
library(sampling)
library(ggplot2)
library(gridExtra)

set.seed(0)
```

# Preprocesamiento de los datos

```{r data_processing, include=FALSE}
is_nbi_missing <- function(x) x %in% c(8, 9)
is_nbi_var <- function() starts_with("NBI_")
mutate_nbi <- function(x) zap_labels(x) %>% if_else(is_nbi_missing(.), 0, .)
select_nbi <- function(x) select(x, is_nbi_var(), -NBI_CANTIDAD)
has_xo <- function(x) if_else(x$HOGCE09 == 0, 1, 0)
has_nbi <- function(x) if_else(x$NBI_TOTAL >= 4, 1, 0)

load("datos.RData")
data <- rio_branco %>%
  mutate(across(is_nbi_var(), ~ mutate_nbi(.))) %>%
  mutate(NBI_TOTAL = rowSums(select_nbi(.)), XO = has_xo(.)) %>%
  mutate(NBI = has_nbi(.), ID = paste(ID_VIVIENDA, HOGID)) %>%
  filter(!duplicated(ID)) %>%
  select(nbi = NBI, xo = XO)

t_nbi <- sum(data$nbi)
t_xo <- sum(data$xo)

N <- nrow(data)
```


# Distribución empírica del estimador

En esta parte presentamos el marco de trabajo del análisis.
Definimos funciones auxiliares para automatizar el análisis y estandarizar y simplificar la presentación de los resultados.
El objetivo es abstraer los procedimientos a ser realizaos de los tamaños de muestra y de los diseños de muestreo.
Para esto, utilizamos el paquete `survey`.

## Funciones Auxiliares

Definimos funciones auxiliares para facilitar el resto del análisis:

- `estimate_total` recibe un nombre de variable y un diseño de muestreo para estimar un total poblacional. Envuelve la función `svytotal` del paquete `survey` para facilitar su uso.
- `estimate_totals` recibe un nombre de variable y una lista de diseños de muestreo y estima el total poblacional para cada diseño. Se utiliza especialmente para automatizar la aplicación sobre varios tamaños de muestra.
- `show_results` recibe un nombre de variable y una lista de resultados para mostrarlos de forma estándar.
- `confint_norm` recibe un estimador (resultado de `svytotal`) y calcula el intervalo de confianza al 95% asumiendo distribución normal.

```{r auxiliar}
estimate_total <- function(var, design) {
  svytotal(as.formula(paste0("~", var)), design, deff = TRUE)
}

estimate_totals <- function(var, design_list) {
  lapply(design_list, function(design) estimate_total(var, design))
}

show_results <- function(var, named_result_list) {
  as.data.frame(t(named_result_list), row.names = var)
}

confint_norm <- function(t_estimate) {
  t <- coef(t_estimate)
  se <- SE(t_estimate)

  ci <- cbind(
    t - qnorm(0.975) * se,
    t + qnorm(0.975) * se
  )
  colnames(ci) <- c("2.5%", "97.5%")
  ci
}
```

## Muestreo del estimador

Obtenemos 1000 muestras y calculamos el estimador del total poblacional para cada una de ellas.
La función `sample_t_estimate` implementa este procedimiento genéricamente, recibiendo como parámetros:

- `var` La variable que se desea estimar
- `sample_size` el tamaño de las muestras que se deben tomar
- `get_sample` una función que dado valor `n` devuelve una muestra de tamaño `n`
- `get_design` una función que dada una muestra devuelve un objeto de diseño de muestreo generado con `svydesign`

```{r estimate_dist_sample}
sample_t_estimate <- function(var, sample_size, get_sample, get_design) {
  n_simulations <- 1000

  replicate(n_simulations, {
    sample <- get_sample(sample_size)
    design <- get_design(sample)
    coef(estimate_total(var, design))
  })
}
```

Utiliza `estimate_total` para estimar el total poblacional para la variable indicada.
Además, definimos la función `empirical_distribution_sir` (cuyo código no está expuesto en el informe)
que toma los mismos parámetros, utiliza `sample_t_estimate`, grafica la distribución empírica
y retorna resúmenes de la distribución empírica del estimador, como la media, la varianza y los intervalos de confianza empíricos al 95% de confianza,
para cada tamaño de muestra.

```{r estimate_dist_plots, include=FALSE}
empirical_distribution_sir <-
  function(var, sample_sizes, get_sample, get_design) {
    result <- lapply(sample_sizes, function(sample_size) {
      # Simular
      t <- data.frame(
        estimate = sample_t_estimate(var, sample_size, get_sample, get_design)
      )

      # Regla de Scott para el ancho de los bins
      binwidth <- 3.5 * sd(t$estimate) / (sample_size^(1 / 3))

      # Graficar Histograma + Curva de densidad
      plot <- ggplot(t, aes(x = estimate, y = after_stat(density))) +
        geom_histogram(binwidth = binwidth, color = "black", fill = "white") +
        geom_density(alpha = 0.2, fill = "blue") +
        geom_vline(
          aes(xintercept = get(paste0("t_", var))),
          color = "red",
          linewidth = 0.7
        ) +
        geom_vline(
          aes(xintercept = mean(t$estimate)),
          color = "blue",
          linewidth = 0.7
        ) +
        labs(
          x = var,
          y = "Density",
          title = paste0("Función de Densidad Empírica - n = ", sample_size)
        ) +
        theme_classic()


      list(
        plot = plot,
        q95 = quantile(t$estimate, c(0.025, 0.975)),
        mean = mean(t$estimate),
        var = var(t$estimate)
      )
    })

    plots <- lapply(result, function(r) r$plot)
    quantiles <- lapply(result, function(r) r$q95)
    means <- lapply(result, function(r) r$mean)
    variances <- lapply(result, function(r) r$var)
    names(quantiles) <- names(means) <- names(variances) <- sample_sizes


    grid.arrange(grobs = plots, padding = 5)

    list(
      quantiles = as.data.frame(t(as.data.frame(quantiles))),
      means = as.data.frame(t(as.data.frame(means))),
      variances = as.data.frame(t(as.data.frame(variances)))
    )
  }
```

# Diseño de muestreo SIR

En esta parte analizamos el diseño **Simple con Reposición (SIR)**.
En primera instancia, definimos los artefactos necesarios para utilizar nuestro marco de trabajo.
Luego, estimamos la distribución empírica del estimador del total poblacional para `nbi` y para `xo`
y comparamos sus características con el parámetro poblacional y con el estimador teórico de la varianza del estimador poblacional.

## Definición del diseño

Definimos la función `get_sir_design` que recibe una muestra y genera un objeto de diseño de muestreo
con `svydesign` del paquete `survey` de la siguiente manera:

```{r sir_design}
get_sir_design <- function(sample) {
  svydesign(
    ids = ~1,
    data = sample,
    probs = nrow(sample) / N
  )
}
```

En este caso, la estrategia de muestreo es diseño SIR con estimador $t_{pwr}$.
Entonces, la probabilidad de inclusión de cada unidad es la misma para todas las unidades y está definida como
$n \ N$, dónde $n$ es el tamaño de la muestra y $N$ es el tamaño de la población.

## Algoritmo de selección

Definimos la función `get_sir_sample` que recibe el tamaño de la muestra y devuelve una muestra de tamaño `n` utilizando el método SIR.
Específicamente, esto se implementa utilizando la función `srswr` del paquete `sampling`.

```{r sir_sampling}
get_sir_sample <- function(sample_size) {
  index <- srswr(sample_size, N)
  getdata(data, index)
}
```

## Obtener muestras finales

Utilizamos la función `get_sir_sample` para obtener muestras de tamaño 150, 600 y 1000
y almacenarlas en la lista `sir_samples`.

```{r sir_samples}
sample_sizes <- c(150, 600, 1000)
sir_samples <- lapply(sample_sizes, get_sir_sample)
names(sir_samples) <- sample_sizes
```

## Obtener objetos de diseño finales

Utilizamos la función `get_sir_design` para obtener los objetos de diseño de muestreo finales
para cada muestra. Almacenamos estos objetos en la lista `sir_designs`.

```{r sir_designs}
sir_designs <- lapply(sir_samples, get_sir_design)
```

## Análisis de NBI

En esta parte analizamos los resultados obtenidos para la variable `nbi`.

### Distribución empírica del estimador para el total de NBI

Utilizamos la función `empirical_distribution_sir` para obtener y visualizar la distribución empírica del estimador.
Esta función utiliza internamente a la función `sample_t_estimate` presentada anteriormente.
Para esto es necesario pasar las funciones  `get_sir_sample` y `get_sir_design` definidas recién como parámetros.

Como resultado, obtenemos resúmenes de la distibución empírica y los en la variable `t_nbi_dist`.
Además visualizamos la distribución empírica para cada tamaño de muestra mediante histogramas y la función de densidad empírica.
Destacamos el valor real del total poblacional de `nbi` como una línea vertical roja y el promedio muestral como una línea vertical azul.

```{r sir_nbi_estimate_dist, results='show'}
t_nbi_dist <- empirical_distribution_sir(
  "nbi",
  sample_sizes,
  get_sir_sample,
  get_sir_design
)
```

### Estimación puntual del total de NBI

```{r sir_nbi_estimate}
t_nbi_estimates <- estimate_totals("nbi", sir_designs)
show_results("nbi", t_nbi_estimates)
```

### Efecto diseño del estimador para el total de NBI

```{r sir_nbi_estimate_deff}
t_nbi_estimates_deff <- lapply(t_nbi_estimates, deff)
show_results("nbi", t_nbi_estimates_deff)
```

### Intervalos de confianza para el total de NBI

```{r sir_nbi_estimate_quantiles}
t_nbi_dist$quantiles$range <- t_nbi_dist$quantiles$"97.5%" - t_nbi_dist$quantiles$"2.5%"
t_nbi_dist$quantiles
```

```{r sir_nbi_estimate_confint}
t_nbi_confint <- as.data.frame(do.call(rbind, lapply(t_nbi_estimates, confint_norm)))
t_nbi_confint$range <- t_nbi_confint$"97.5%" - t_nbi_confint$"2.5%"
rownames(t_nbi_confint) <- sample_sizes
t_nbi_confint
```

## Análisis de XO

### Distribución empírica del estimador para el total de XO

```{r sir_xo_estimate_dist, echo=FALSE, results='show'}
empirical_distribution_sir(
  "xo",
  sample_sizes,
  get_sir_sample,
  get_sir_design
)
```

